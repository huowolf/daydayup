# 索引失效的10种场景

![img](https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5ianHlF0AzOr530aPCbgeARxMduoIvwQDZJJOOSIKFHwAdXQTOzBnEWOlvY9lR9matXZ8joTruQl4Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## 1、准备工作

### 1.1、创建user表

创建一张user表。

```sql
CREATE TABLE `user` (
  `id` int NOT NULL AUTO_INCREMENT,
  `code` varchar(20)  DEFAULT NULL,
  `age` int DEFAULT '0',
  `name` varchar(30)  DEFAULT NULL,
  `height` int DEFAULT '0',
  `address` varchar(30)  DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_code_age_name` (`code`,`age`,`name`),
  KEY `idx_height` (`height`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin
```

此外，还创建了三个索引：

- `id`：数据库的主键
- `idx_code_age_name`：由code、age和name三个字段组成的联合索引。
- `idx_height`：普通索引

### 1.2、插入数据

```sql
INSERT INTO test.user (CODE, age, NAME, height,address) VALUES ('101', 21, '周星驰', 175,'香港');
INSERT INTO test.user (CODE, age, NAME, height,address) VALUES ('102', 18, '周杰伦', 173,'台湾');
INSERT INTO test.user (CODE, age, NAME, height,address) VALUES ('103', 23, '苏三', 174,'成都');
```

## 2、不满足最左匹配原则

之前我已经给code、age和name这3个字段建好`联合索引`：idx_code_age_name。

该索引字段的顺序是：

- code
- age
- name

如果在使用联合索引时，没注意最左前缀原则，很有可能导致索引失效喔。

### 2.1 哪些情况索引有效？

先看看哪些情况下，能走索引。

```sql
explain select * from user
where code='101';
```

```sql
explain select * from user
where code='101' and age=21 
```

```sql
explain select * from user
where code='101' and age=21 and name='周星驰';
```

上面三种情况，sql都能正常走索引。

其实还有一种比较特殊的场景：

```sql
explain select * from user
where code = '101'  and name='周星驰';
```

查询条件原本的顺序是：code、age、name，但这里只有code和name中间断层了，掉了age字段，这种情况也能走code字段上的索引。

**这4条sql中都有code字段，它是索引字段中的第一个字段，也就是最左边的字段。只要有这个字段在，该sql已经就能走索引。**

### 2.2 哪些情况索引失效？

接下来，我们重点看看哪些情况下索引会失效。

```sql
explain select * from user
where age=21;
```

```sql
explain select * from user
where name='周星驰';
```

```sql
explain select * from user
where age=21 and name='周星驰';
```

这3种情况下索引确实失效了。

说明以上3种情况不满足最左匹配原则，说白了是因为查询条件中，没有包含给定字段最左边的索引字段，即字段code。

## 3、使用了select *

在《阿里巴巴开发手册》中明确说过，查询sql中禁止使用`select *` 。

那么，你知道为什么吗？

废话不多说，按照国际惯例先上一条sql：

```sql
explain 
select * from user where name='苏三';
```

在该sql中用了`select *`，从执行结果看，走了全表扫描，没有用到任何索引，查询效率是非常低的。

如果查询的时候，只查我们真正需要的列，而不查所有列，结果会怎么样？

非常快速的将上面的sql改成只查了code和name列，太easy了：

```sql
explain 
select code,name from user 
where name='苏三';
```

从图中执行结果不难看出，该sql语句这次走了`全索引扫描`，比`全表扫描`效率更高。

其实这里用到了：`覆盖索引`。

如果select语句中的查询列，都是索引列，那么这些列被称为覆盖索引。这种情况下，查询的相关字段都能走索引，索引查询效率相对来说更高一些。

而使用`select *`查询所有列的数据，大概率会查询非索引列的数据，非索引列不会走索引，查询效率非常低。

## 4、 索引列上有计算

介绍本章节内容前，先跟大家一起回顾一下，根据id查询数据的sql语句：

```sql
explain select * from user where id=1;
```

从图中可以看出，由于id字段是主键，该sql语句用到了`主键索引`。

但如果id列上面有计算，比如：

```sql
explain select * from user where id+1=2;
```

从上图中的执行结果，能够非常清楚的看出，该id字段的主键索引，在有计算的情况下失效了。

## 5、 索引列用了函数

有时候我们在某条sql语句的查询条件中，需要使用函数，比如：截取某个字段的长度。

假如现在有个需求：想查出所有身高是17开头的人，如果sql语句写成这样：

```sql
explain select * from user  where SUBSTR(height,1,2)=17;
```

这时需要用到`SUBSTR`函数，用它截取了height字段的前面两位字符，从第一个字符开始。

在使用该函数之后，该sql语句竟然走了全表扫描，索引失效了。

## 6、 字段类型不同

在sql语句中因为字段类型不同，而导致索引失效的问题，很容易遇到，可能是我们日常工作中最容易忽略的问题。

到底怎么回事呢？

请大家注意观察一下t_user表中的code字段，它是`varchar`字符类型的。

在sql语句中查询数据时，查询条件我们可以写成这样：

```sql
explain 
select * from user where code="101";
```

该code字段走了索引。

但如果你在写sql时，不小心把引号弄掉了，把sql语句变成了：

```sql
explain 
select * from user where code=101;
```

你会惊奇的发现，该sql语句竟然变成了全表扫描。因为少写了引号，这种小小的失误，竟然让code字段上的索引失效了。

这时你心里可能有一万个为什么，其中有一个肯定是：为什么索引会失效呢？

答：因为code字段的类型是varchar，而传参的类型是int，两种类型不同。

此外，还有一个有趣的现象，如果int类型的height字段，在查询时加了引号条件，却还可以走索引：

```sql
explain select * from user 
where height='175';
```

mysql发现如果是`int`类型字段作为查询条件时，它会自动将该字段的传参进行`隐式转换`，把字符串转换成int类型。

mysql会把上面列子中的字符串175，转换成数字175，所以仍然能走索引。

接下来，看一个更有趣的sql语句：

```sql
select 1 + '1';
```

它的执行结果是2，还是11呢？

mysql自动把字符串1，转换成了int类型的1，然后变成了：1+1=2。

